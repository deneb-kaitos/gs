import {
  randomUUID,
} from 'node:crypto';
import {
  createClient,
} from 'redis';
import {
  WebsocketCodes,
} from '@deneb-kaitos/wscodes';

export class Handlers {
  /** @type {import('util').DebugLogger} */
  #debuglog = null;
  #decoder = new TextDecoder();
  #encoder = new TextEncoder();
  /** @type {WeakMap} */
  #clientsProperties = null;
  /** @type {Map} */
  #clients = null;
  #redisConfig = null;
  /** @type {import('redis').RedisClientType || null} */
  #redisClient = null;
  #serverId = null;
  #streamOpts = null;
  #sinkStreamName = null;
  #AUTOGENERATED_ID = '*';

  /** @param {import('util').DebugLogger} debuglog  */
  constructor(redisConfig, streamOpts, sinkStreamName, serverId, debuglog) {
    this.#redisConfig = Object.freeze(Object.assign(Object.create(null), redisConfig));
    this.#streamOpts = Object.freeze(Object.assign(Object.create(null), streamOpts));
    this.#sinkStreamName = sinkStreamName;
    this.#serverId = serverId;
    this.#debuglog = debuglog;
    this.#clientsProperties = new WeakMap();
    this.#clients = new Map();

    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this.open = this.open.bind(this);
    this.close = this.close.bind(this);
    this.message = this.message.bind(this);
  }

  async start() {
    this.#redisClient = createClient(this.#redisConfig);

    this.#debuglog(`${this.constructor.name}.start`);

    return await this.#redisClient.connect();
  }

  async stop() {
    await this.#redisClient.quit();

    this.#redisClient = undefined;

    this.#debuglog(`${this.constructor.name}.stop`);
  }

  /** @property {import('uWebSockets.js').WebSocket} ws */
  /**
   * @param {import('uWebSockets.js').WebSocket} ws
   * @param {WebsocketCodes} wsCode
   * @param {string} closeMessage
   */
  #killClient(ws, wsCode, closeMessage) {
    const { id } = this.#clientsProperties.get(ws);

    ws.end(wsCode, this.#encoder.encode(closeMessage));

    this.#clients.delete(id);
  }

  open(ws) {
    const id = randomUUID();

    this.#clientsProperties.set(ws, {
      id,
    });
    this.#clients.set(id, ws);

    this.#debuglog(`websocket connected: ${id}`);
  }

  /**
   *
   * @param {*} ws
   * @param {ArrayBuffer} msg
   * @param {*} isBinary
   * @returns
   */
  async message(ws, msg, isBinary) {
    if (isBinary === false) {
      this.#debuglog(`[ER] message.isBinary: ${isBinary}`);

      this.#killClient(ws, WebsocketCodes.UNSUPPORTED_PAYLOAD, 'message must be binary');

      return;
    }

    const streamMessage = {
      sid: this.#serverId, // websocket server id
      cid: (this.#clientsProperties.get(ws)).id, // websocket client id
      payload: Buffer.from(msg).toString('ascii'),
    };

    try {
      await this.#redisClient.executeIsolated(async (isolatedClient) => await isolatedClient.xAdd(
        this.#sinkStreamName,
        this.#AUTOGENERATED_ID,
        streamMessage,
        this.#streamOpts,
      ));
    } catch (err) {
      this.#debuglog('[ER] .message::isolatedClient', err);
    }

    ws.send(this.#encoder.encode(JSON.stringify({ ok: true })));
  }

  close(ws, code, message) {
    const { id } = this.#clientsProperties.get(ws);

    this.#debuglog(`websocket [${id}] closed with code [${code}] and message:`, this.#decoder.decode(message));
  }
}
